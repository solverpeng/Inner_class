# 内部类
## 什么是内部类
一个类定义在另一个类或者一个方法里，称为内部类

## 为什么要使用内部类
每个内部类都可以单独的实现一个接口或是继承一个类，以此来达到多重继承的效果。参见 Man.java Person.java Wing.java

## 分类
### 成员内部类
参见 com.solverpeng.innerclass.field 包

（1）成员内部类可以无条件访问外部类的所有成员属性和成员方法

（2）若成员内部类拥有和外部类相同的成员变量或方法时，在成员内部类内，默认会调用成员内部类的成员。如果要访问外部类的同名成员，需要以如下方式去访问：

外部类.this.成员变量
外部类.this.成员方法

（3）编译后会出现两个 Class 文件，且内部类会持有外部类对象的一个引用

（4）编译后会出现两个 class 文件
### 局部内部类
参见 com.solverpeng.innerclass.part.method 包，包括方法内部类和作用域内部类。需要注意在内部类中使用到外部传入的参数时，该参数需要被 final 修饰

（1）局部内部类的访问仅限于方法内或者该作用域内

（2）具备内部类就像是方法里面的一个局部变量一样，不能有 public/protected/private/static 修饰

（3）编译后会出现两个 class 文件
### 匿名内部类
参见 com.solverpeng.innerclass.anonymous 包
（1）匿名内部类不能有访问修饰符和static修饰符

（2）匿名内部类在编译的时候由系统自动起名为：OuterClass$n.class 其中 n 为正整数

（3）编译后会出现两个 class 文件
### 静态内部类
参见 com.solverpeng.innerclass.mystatic 包
（1）静态内部类不依赖于外部类，所以只能访问外部类的static成员变量和方法

（2）编译后会出现两个 class 文件

## 问题
### 为什么局部内部类和匿名内部类只能访问局部 final 变量
在局部内部类或匿名内部类中访问的局部变量，本质上是本地局部变量的复制，出于数据一致性的考虑，需要 final 修饰
（1）若变量的值在编译期间可以确定，则会在局部内部类或匿名内部类中创建一个拷贝

（2）若局部变量的值在编译期间无法确定，则通过构造器传参的方式来对拷贝进行初始化赋值

说明：反编译局部内部类和匿名内部类，会发现存在两个构造器，一个无参的，一个带参的（参数：一个指向外部类的引用，其余就是方法形参）

## 内部类使用场景和好处
每个内部类都能独立继承一个类或实现一个接口，所以无论外部类是否已经继承了某个类或实现了某个接口，对内部类没有影响，使得多继承方案变的完整。
简而言之，内部类的存在使得Java的多继承机制变得更加完善

## 创建静态内部类对象的一般形式为
外部类类名.内部类类名 xxx = new 外部类类名.内部类类名()

## 创建成员内部类对象的一般形式为
外部类类名.内部类类名 xxx = 外部类对象名.new 内部类类名()

## 参考资料
http://www.cnblogs.com/dolphin0520/p/3811445.html


